
./Debug/keypad.elf:     file format elf32-littlearm


Disassembly of section .text:

20000000 <startup>:

 
__attribute__((naked)) __attribute__((section (".start_section")) )
void startup ( void )
{
__asm__ volatile(" LDR R0,=0x2001C000\n");		/* set stack */
20000000:	4802      	ldr	r0, [pc, #8]	; (2000000c <startup+0xc>)
__asm__ volatile(" MOV SP,R0\n");
20000002:	4685      	mov	sp, r0
__asm__ volatile(" BL main\n");					/* call main */
20000004:	f000 f914 	bl	20000230 <main>
__asm__ volatile(".L1: B .L1\n");				/* never return */
20000008:	e7fe      	b.n	20000008 <startup+0x8>
}
2000000a:	46c0      	nop			; (mov r8, r8)
2000000c:	2001c000 	andcs	ip, r1, r0

20000010 <init_GPIO_D_keypad_HIGH>:

// -----------------------------------------------------------------------------

void init_GPIO_D_keypad_HIGH (void) {				// Initierar Keypaden på höga bytes
20000010:	b580      	push	{r7, lr}
20000012:	af00      	add	r7, sp, #0
	* GPIO_D_MODER &= 0x0000FFFF;				// Nollställer de 2 höga bytesen i MODER-registret och har samtidigt kvar eventuella tidigare inskrivningar i de låga.
20000014:	4b13      	ldr	r3, [pc, #76]	; (20000064 <init_GPIO_D_keypad_HIGH+0x54>)
20000016:	681a      	ldr	r2, [r3, #0]
20000018:	4b12      	ldr	r3, [pc, #72]	; (20000064 <init_GPIO_D_keypad_HIGH+0x54>)
2000001a:	0412      	lsls	r2, r2, #16
2000001c:	0c12      	lsrs	r2, r2, #16
2000001e:	601a      	str	r2, [r3, #0]
	* GPIO_D_MODER |= 0x55000000;					// 0101 0101 den högsta byten vilket gör porten till en utport och 0000 0000 den näst högsta porten vilket gör den till en inport. Har samtidigt kvar eventuella bitar på de låga bytesen.
20000020:	4b10      	ldr	r3, [pc, #64]	; (20000064 <init_GPIO_D_keypad_HIGH+0x54>)
20000022:	681a      	ldr	r2, [r3, #0]
20000024:	4b0f      	ldr	r3, [pc, #60]	; (20000064 <init_GPIO_D_keypad_HIGH+0x54>)
20000026:	21aa      	movs	r1, #170	; 0xaa
20000028:	05c9      	lsls	r1, r1, #23
2000002a:	430a      	orrs	r2, r1
2000002c:	601a      	str	r2, [r3, #0]
	
	* GPIO_D_OTYPER &= 0x00FF;						// Nollställer den höga byten i OTYPER-registret och har samtidigt kvar eventuella tidigare inskrivningar i de låga.
2000002e:	4b0e      	ldr	r3, [pc, #56]	; (20000068 <init_GPIO_D_keypad_HIGH+0x58>)
20000030:	881b      	ldrh	r3, [r3, #0]
20000032:	4a0d      	ldr	r2, [pc, #52]	; (20000068 <init_GPIO_D_keypad_HIGH+0x58>)
20000034:	21ff      	movs	r1, #255	; 0xff
20000036:	400b      	ands	r3, r1
20000038:	b29b      	uxth	r3, r3
2000003a:	8013      	strh	r3, [r2, #0]
	* GPIO_D_OTYPER |= 0x0000;							// 0000 0000 på den  höga byten i registrert vilket sätter dessa portpinnar till PUSH-PULL. Har samtidigt kvar eventuella bitar på de låga bytesen.		(onödig kanske?)
2000003c:	4a0a      	ldr	r2, [pc, #40]	; (20000068 <init_GPIO_D_keypad_HIGH+0x58>)
2000003e:	4b0a      	ldr	r3, [pc, #40]	; (20000068 <init_GPIO_D_keypad_HIGH+0x58>)
20000040:	8812      	ldrh	r2, [r2, #0]
20000042:	801a      	strh	r2, [r3, #0]
	
	* GPIO_D_PUPDR &= 0x0000FFFF;					// Nollställer de 2 höga bytesen i PUPDR-registret och har samtidigt kvar eventuella tidigare inskrivningar i de låga.
20000044:	4b09      	ldr	r3, [pc, #36]	; (2000006c <init_GPIO_D_keypad_HIGH+0x5c>)
20000046:	681a      	ldr	r2, [r3, #0]
20000048:	4b08      	ldr	r3, [pc, #32]	; (2000006c <init_GPIO_D_keypad_HIGH+0x5c>)
2000004a:	0412      	lsls	r2, r2, #16
2000004c:	0c12      	lsrs	r2, r2, #16
2000004e:	601a      	str	r2, [r3, #0]
	* GPIO_D_PUPDR |= 0x00AA0000;					// 0000 0000 den högsta byten vilket konfigurerar motsvarande 4 port-pinnar till FLOATING och 0101 0101 den näst högsta porten konfigurerar motsvarande 4 port-pinnar till PULL-DOWN. Har samtidigt kvar eventuella bitar på de låga bytesen.
20000050:	4b06      	ldr	r3, [pc, #24]	; (2000006c <init_GPIO_D_keypad_HIGH+0x5c>)
20000052:	681a      	ldr	r2, [r3, #0]
20000054:	4b05      	ldr	r3, [pc, #20]	; (2000006c <init_GPIO_D_keypad_HIGH+0x5c>)
20000056:	21aa      	movs	r1, #170	; 0xaa
20000058:	0409      	lsls	r1, r1, #16
2000005a:	430a      	orrs	r2, r1
2000005c:	601a      	str	r2, [r3, #0]
}
2000005e:	46c0      	nop			; (mov r8, r8)
20000060:	46bd      	mov	sp, r7
20000062:	bd80      	pop	{r7, pc}
20000064:	40020c00 	andmi	r0, r2, r0, lsl #24
20000068:	40020c04 	andmi	r0, r2, r4, lsl #24
2000006c:	40020c0c 	andmi	r0, r2, ip, lsl #24

20000070 <init_GPIO_D_7SegmentDisplay_LOW>:

void init_GPIO_D_7SegmentDisplay_LOW (void) {
20000070:	b580      	push	{r7, lr}
20000072:	af00      	add	r7, sp, #0
	* GPIO_D_MODER &= 0xFFFF0000;				// Nollställer de 2 lägsta bytesen i MODER-registret och har samtidigt kvar eventuella tidigare inskrivningar i de höga. 
20000074:	4b07      	ldr	r3, [pc, #28]	; (20000094 <init_GPIO_D_7SegmentDisplay_LOW+0x24>)
20000076:	681a      	ldr	r2, [r3, #0]
20000078:	4b06      	ldr	r3, [pc, #24]	; (20000094 <init_GPIO_D_7SegmentDisplay_LOW+0x24>)
2000007a:	0c12      	lsrs	r2, r2, #16
2000007c:	0412      	lsls	r2, r2, #16
2000007e:	601a      	str	r2, [r3, #0]
	* GPIO_D_MODER |= 0x00005555;					// 0101 0101 de två lägsta byten vilket gör porten till en utport. Har samtidigt kvar eventuella bitar på de låga bytesen.
20000080:	4b04      	ldr	r3, [pc, #16]	; (20000094 <init_GPIO_D_7SegmentDisplay_LOW+0x24>)
20000082:	681a      	ldr	r2, [r3, #0]
20000084:	4b03      	ldr	r3, [pc, #12]	; (20000094 <init_GPIO_D_7SegmentDisplay_LOW+0x24>)
20000086:	4904      	ldr	r1, [pc, #16]	; (20000098 <init_GPIO_D_7SegmentDisplay_LOW+0x28>)
20000088:	430a      	orrs	r2, r1
2000008a:	601a      	str	r2, [r3, #0]
}
2000008c:	46c0      	nop			; (mov r8, r8)
2000008e:	46bd      	mov	sp, r7
20000090:	bd80      	pop	{r7, pc}
20000092:	46c0      	nop			; (mov r8, r8)
20000094:	40020c00 	andmi	r0, r2, r0, lsl #24
20000098:	00005555 	andeq	r5, r0, r5, asr r5

2000009c <app_init>:

void app_init(void) {										// Kallar på de två ovantsående init funktionerna.
2000009c:	b580      	push	{r7, lr}
2000009e:	af00      	add	r7, sp, #0
	#ifdef USBDM
		*((unsigned long *) 0x40023830) = 0x18;
	#endif
	
	init_GPIO_D_keypad_HIGH();
200000a0:	f7ff ffb6 	bl	20000010 <init_GPIO_D_keypad_HIGH>
	init_GPIO_D_7SegmentDisplay_LOW();
200000a4:	f7ff ffe4 	bl	20000070 <init_GPIO_D_7SegmentDisplay_LOW>
}
200000a8:	46c0      	nop			; (mov r8, r8)
200000aa:	46bd      	mov	sp, r7
200000ac:	bd80      	pop	{r7, pc}

200000ae <keybActivate>:

// -------------------------------------------------------------------------

void keybActivate (unsigned int row) {
200000ae:	b580      	push	{r7, lr}
200000b0:	b082      	sub	sp, #8
200000b2:	af00      	add	r7, sp, #0
200000b4:	6078      	str	r0, [r7, #4]
	// Kollar vilken rad som knappen är itryckt på och sparar detta i D-portens HÖGA BYTE (inget kopplat hit).				VARFÖR SPARAR MAN DET HÄR????
	switch(row) {
200000b6:	687b      	ldr	r3, [r7, #4]
200000b8:	2b04      	cmp	r3, #4
200000ba:	d01b      	beq.n	200000f4 <keybActivate+0x46>
200000bc:	687b      	ldr	r3, [r7, #4]
200000be:	2b04      	cmp	r3, #4
200000c0:	d81c      	bhi.n	200000fc <keybActivate+0x4e>
200000c2:	687b      	ldr	r3, [r7, #4]
200000c4:	2b03      	cmp	r3, #3
200000c6:	d011      	beq.n	200000ec <keybActivate+0x3e>
200000c8:	687b      	ldr	r3, [r7, #4]
200000ca:	2b03      	cmp	r3, #3
200000cc:	d816      	bhi.n	200000fc <keybActivate+0x4e>
200000ce:	687b      	ldr	r3, [r7, #4]
200000d0:	2b01      	cmp	r3, #1
200000d2:	d003      	beq.n	200000dc <keybActivate+0x2e>
200000d4:	687b      	ldr	r3, [r7, #4]
200000d6:	2b02      	cmp	r3, #2
200000d8:	d004      	beq.n	200000e4 <keybActivate+0x36>
200000da:	e00f      	b.n	200000fc <keybActivate+0x4e>
		case 1: * GPIO_ODR_HIGH = 0x10; break;
200000dc:	4b0b      	ldr	r3, [pc, #44]	; (2000010c <keybActivate+0x5e>)
200000de:	2210      	movs	r2, #16
200000e0:	701a      	strb	r2, [r3, #0]
200000e2:	e00f      	b.n	20000104 <keybActivate+0x56>
		case 2: * GPIO_ODR_HIGH = 0x20; break;
200000e4:	4b09      	ldr	r3, [pc, #36]	; (2000010c <keybActivate+0x5e>)
200000e6:	2220      	movs	r2, #32
200000e8:	701a      	strb	r2, [r3, #0]
200000ea:	e00b      	b.n	20000104 <keybActivate+0x56>
		case 3: * GPIO_ODR_HIGH = 0x40; break;
200000ec:	4b07      	ldr	r3, [pc, #28]	; (2000010c <keybActivate+0x5e>)
200000ee:	2240      	movs	r2, #64	; 0x40
200000f0:	701a      	strb	r2, [r3, #0]
200000f2:	e007      	b.n	20000104 <keybActivate+0x56>
		case 4: * GPIO_ODR_HIGH = 0x80; break;
200000f4:	4b05      	ldr	r3, [pc, #20]	; (2000010c <keybActivate+0x5e>)
200000f6:	2280      	movs	r2, #128	; 0x80
200000f8:	701a      	strb	r2, [r3, #0]
200000fa:	e003      	b.n	20000104 <keybActivate+0x56>
		default: * GPIO_ODR_HIGH = 0;
200000fc:	4b03      	ldr	r3, [pc, #12]	; (2000010c <keybActivate+0x5e>)
200000fe:	2200      	movs	r2, #0
20000100:	701a      	strb	r2, [r3, #0]
	}
}
20000102:	46c0      	nop			; (mov r8, r8)
20000104:	46c0      	nop			; (mov r8, r8)
20000106:	46bd      	mov	sp, r7
20000108:	b002      	add	sp, #8
2000010a:	bd80      	pop	{r7, pc}
2000010c:	40020c15 	andmi	r0, r2, r5, lsl ip

20000110 <keybGetCol>:

int keybGetCol (void) {
20000110:	b580      	push	{r7, lr}
20000112:	b082      	sub	sp, #8
20000114:	af00      	add	r7, sp, #0
	/* Om någon tangent (i aktiverad rad)
	 * är nedtryckt, returnera dess kolumnnummer,
	 * annars, returnera 0 */
	unsigned char rowFromRegister;
	rowFromRegister = * GPIO_IDR_HIGH;
20000116:	4a12      	ldr	r2, [pc, #72]	; (20000160 <keybGetCol+0x50>)
20000118:	1dfb      	adds	r3, r7, #7
2000011a:	7812      	ldrb	r2, [r2, #0]
2000011c:	701a      	strb	r2, [r3, #0]
	if (rowFromRegister & 8) return 4;
2000011e:	1dfb      	adds	r3, r7, #7
20000120:	781b      	ldrb	r3, [r3, #0]
20000122:	2208      	movs	r2, #8
20000124:	4013      	ands	r3, r2
20000126:	d001      	beq.n	2000012c <keybGetCol+0x1c>
20000128:	2304      	movs	r3, #4
2000012a:	e015      	b.n	20000158 <keybGetCol+0x48>
	if (rowFromRegister & 4) return 3;
2000012c:	1dfb      	adds	r3, r7, #7
2000012e:	781b      	ldrb	r3, [r3, #0]
20000130:	2204      	movs	r2, #4
20000132:	4013      	ands	r3, r2
20000134:	d001      	beq.n	2000013a <keybGetCol+0x2a>
20000136:	2303      	movs	r3, #3
20000138:	e00e      	b.n	20000158 <keybGetCol+0x48>
	if (rowFromRegister & 2) return 2;
2000013a:	1dfb      	adds	r3, r7, #7
2000013c:	781b      	ldrb	r3, [r3, #0]
2000013e:	2202      	movs	r2, #2
20000140:	4013      	ands	r3, r2
20000142:	d001      	beq.n	20000148 <keybGetCol+0x38>
20000144:	2302      	movs	r3, #2
20000146:	e007      	b.n	20000158 <keybGetCol+0x48>
	if (rowFromRegister & 1) return 1;
20000148:	1dfb      	adds	r3, r7, #7
2000014a:	781b      	ldrb	r3, [r3, #0]
2000014c:	2201      	movs	r2, #1
2000014e:	4013      	ands	r3, r2
20000150:	d001      	beq.n	20000156 <keybGetCol+0x46>
20000152:	2301      	movs	r3, #1
20000154:	e000      	b.n	20000158 <keybGetCol+0x48>
	return 0;
20000156:	2300      	movs	r3, #0
}
20000158:	0018      	movs	r0, r3
2000015a:	46bd      	mov	sp, r7
2000015c:	b002      	add	sp, #8
2000015e:	bd80      	pop	{r7, pc}
20000160:	40020c11 	andmi	r0, r2, r1, lsl ip

20000164 <out7seg>:

void out7seg (unsigned char c) {
20000164:	b5b0      	push	{r4, r5, r7, lr}
20000166:	b086      	sub	sp, #24
20000168:	af00      	add	r7, sp, #0
2000016a:	0002      	movs	r2, r0
2000016c:	1dfb      	adds	r3, r7, #7
2000016e:	701a      	strb	r2, [r3, #0]
	/* Får in ett tal och sparar detta i D-portens LÅGA BYTE (7seg-display kopplad hit).
	 * Är talet 1,...,15 ?  ---> aktivera motsvarande bitar på 7segdisplay för att visa HEX talet.
	 * Om inte  ---> stäng av 7segdisplay*/
	char display_7seg_hex_to_decimal_array[] ={0x3F,0x06,0x5B,0x4F,0x66,0x6D,0x7D,0x07,0x7F,0x6F,0x77,0x7C,0x39,0x5E,0x79,0x71};			// Array med hex-motsvarigheter för nummer på 7segdisplay.
20000170:	2008      	movs	r0, #8
20000172:	183b      	adds	r3, r7, r0
20000174:	4a0b      	ldr	r2, [pc, #44]	; (200001a4 <out7seg+0x40>)
20000176:	ca32      	ldmia	r2!, {r1, r4, r5}
20000178:	c332      	stmia	r3!, {r1, r4, r5}
2000017a:	6812      	ldr	r2, [r2, #0]
2000017c:	601a      	str	r2, [r3, #0]
	if (c < 16) {
2000017e:	1dfb      	adds	r3, r7, #7
20000180:	781b      	ldrb	r3, [r3, #0]
20000182:	2b0f      	cmp	r3, #15
20000184:	d806      	bhi.n	20000194 <out7seg+0x30>
		* GPIO_ODR_LOW = display_7seg_hex_to_decimal_array[c];
20000186:	1dfb      	adds	r3, r7, #7
20000188:	781b      	ldrb	r3, [r3, #0]
2000018a:	4907      	ldr	r1, [pc, #28]	; (200001a8 <out7seg+0x44>)
2000018c:	183a      	adds	r2, r7, r0
2000018e:	5cd3      	ldrb	r3, [r2, r3]
20000190:	700b      	strb	r3, [r1, #0]
	} else {
		* GPIO_ODR_LOW = 0x0;
	}
}
20000192:	e002      	b.n	2000019a <out7seg+0x36>
		* GPIO_ODR_LOW = 0x0;
20000194:	4b04      	ldr	r3, [pc, #16]	; (200001a8 <out7seg+0x44>)
20000196:	2200      	movs	r2, #0
20000198:	701a      	strb	r2, [r3, #0]
}
2000019a:	46c0      	nop			; (mov r8, r8)
2000019c:	46bd      	mov	sp, r7
2000019e:	b006      	add	sp, #24
200001a0:	bdb0      	pop	{r4, r5, r7, pc}
200001a2:	46c0      	nop			; (mov r8, r8)
200001a4:	20000248 	andcs	r0, r0, r8, asr #4
200001a8:	40020c14 	andmi	r0, r2, r4, lsl ip

200001ac <keyb>:

unsigned char keyb (void) {
200001ac:	b590      	push	{r4, r7, lr}
200001ae:	b087      	sub	sp, #28
200001b0:	af00      	add	r7, sp, #0
	unsigned char key[4][4] = { {1, 2, 3, 10},			// Matris som representerar alla knappar på 16-tangenbord ( OBS i decimalt för att kunna använda som index i hexArrayen i metoden ovan.
200001b2:	1d3b      	adds	r3, r7, #4
200001b4:	4a1d      	ldr	r2, [pc, #116]	; (2000022c <keyb+0x80>)
200001b6:	ca13      	ldmia	r2!, {r0, r1, r4}
200001b8:	c313      	stmia	r3!, {r0, r1, r4}
200001ba:	6812      	ldr	r2, [r2, #0]
200001bc:	601a      	str	r2, [r3, #0]
											    {4, 5, 6, 11},
											    {7, 8, 9, 12},
										     	{14, 0, 15, 13} };
	unsigned char col = 0;
200001be:	2316      	movs	r3, #22
200001c0:	18fb      	adds	r3, r7, r3
200001c2:	2200      	movs	r2, #0
200001c4:	701a      	strb	r2, [r3, #0]
	for (unsigned char row = 1; row <= 4; row++) {		// Loopar igenom alla rader
200001c6:	2317      	movs	r3, #23
200001c8:	18fb      	adds	r3, r7, r3
200001ca:	2201      	movs	r2, #1
200001cc:	701a      	strb	r2, [r3, #0]
200001ce:	e020      	b.n	20000212 <keyb+0x66>
		keybActivate(row);													// Om en knapp på raden är ifylld, spara dess RAD (se metoden ovan).
200001d0:	2417      	movs	r4, #23
200001d2:	193b      	adds	r3, r7, r4
200001d4:	781b      	ldrb	r3, [r3, #0]
200001d6:	0018      	movs	r0, r3
200001d8:	f7ff ff69 	bl	200000ae <keybActivate>
		col = keybGetCol();													// Om en knapp på raden (infon hämtas från HÖGA BYTEN i ODR) är ifylld, spara dess KOLUMN (se metoden ovan). 
200001dc:	f7ff ff98 	bl	20000110 <keybGetCol>
200001e0:	0002      	movs	r2, r0
200001e2:	2116      	movs	r1, #22
200001e4:	187b      	adds	r3, r7, r1
200001e6:	701a      	strb	r2, [r3, #0]
		if ( col != 0 ) {															// Om kolumnen inte är 0, dvs en rad har hämtats från HÖGA BYTEN i ODR och kolumnen för knappen på raden har sparats....
200001e8:	187b      	adds	r3, r7, r1
200001ea:	781b      	ldrb	r3, [r3, #0]
200001ec:	2b00      	cmp	r3, #0
200001ee:	d00a      	beq.n	20000206 <keyb+0x5a>
			return key[row-1][col-1];										// retunera då knappens värde i matrisen, alltså det nummer som står på knappen.
200001f0:	193b      	adds	r3, r7, r4
200001f2:	781b      	ldrb	r3, [r3, #0]
200001f4:	1e5a      	subs	r2, r3, #1
200001f6:	187b      	adds	r3, r7, r1
200001f8:	781b      	ldrb	r3, [r3, #0]
200001fa:	3b01      	subs	r3, #1
200001fc:	1d39      	adds	r1, r7, #4
200001fe:	0092      	lsls	r2, r2, #2
20000200:	188a      	adds	r2, r1, r2
20000202:	5cd3      	ldrb	r3, [r2, r3]
20000204:	e00e      	b.n	20000224 <keyb+0x78>
	for (unsigned char row = 1; row <= 4; row++) {		// Loopar igenom alla rader
20000206:	2117      	movs	r1, #23
20000208:	187b      	adds	r3, r7, r1
2000020a:	781a      	ldrb	r2, [r3, #0]
2000020c:	187b      	adds	r3, r7, r1
2000020e:	3201      	adds	r2, #1
20000210:	701a      	strb	r2, [r3, #0]
20000212:	2317      	movs	r3, #23
20000214:	18fb      	adds	r3, r7, r3
20000216:	781b      	ldrb	r3, [r3, #0]
20000218:	2b04      	cmp	r3, #4
2000021a:	d9d9      	bls.n	200001d0 <keyb+0x24>
		}
	}
	keybActivate(0);
2000021c:	2000      	movs	r0, #0
2000021e:	f7ff ff46 	bl	200000ae <keybActivate>
	return 0xFF;							// Kommer att stänga av displayen då ( FF > 15 )
20000222:	23ff      	movs	r3, #255	; 0xff
}
20000224:	0018      	movs	r0, r3
20000226:	46bd      	mov	sp, r7
20000228:	b007      	add	sp, #28
2000022a:	bd90      	pop	{r4, r7, pc}
2000022c:	20000258 	andcs	r0, r0, r8, asr r2

20000230 <main>:


void main(void) {
20000230:	b580      	push	{r7, lr}
20000232:	af00      	add	r7, sp, #0
	app_init();
20000234:	f7ff ff32 	bl	2000009c <app_init>
	while(1) {
		out7seg(keyb());
20000238:	f7ff ffb8 	bl	200001ac <keyb>
2000023c:	0003      	movs	r3, r0
2000023e:	0018      	movs	r0, r3
20000240:	f7ff ff90 	bl	20000164 <out7seg>
20000244:	e7f8      	b.n	20000238 <main+0x8>
20000246:	46c0      	nop			; (mov r8, r8)
20000248:	4f5b063f 	svcmi	0x005b063f
2000024c:	077d6d66 	ldrbeq	r6, [sp, -r6, ror #26]!
20000250:	7c776f7f 	ldclvc	15, cr6, [r7], #-508	; 0xfffffe04
20000254:	71795e39 	cmnvc	r9, r9, lsr lr
20000258:	0a030201 	beq	200c0a64 <main+0xc0834>
2000025c:	0b060504 	bleq	20181674 <main+0x181444>
20000260:	0c090807 	stceq	8, cr0, [r9], {7}
20000264:	0d0f000e 	stceq	0, cr0, [pc, #-56]	; 20000234 <main+0x4>

Disassembly of section .debug_info:

00000000 <.debug_info>:
   0:	00000193 	muleq	r0, r3, r1
   4:	00000004 	andeq	r0, r0, r4
   8:	01040000 	mrseq	r0, (UNDEF: 4)
   c:	00000000 	andeq	r0, r0, r0
  10:	00018b0c 	andeq	r8, r1, ip, lsl #22
  14:	00008900 	andeq	r8, r0, r0, lsl #18
	...
  24:	01360200 	teqeq	r6, r0, lsl #4
  28:	6f010000 	svcvs	0x00010000
  2c:	00023006 	andeq	r3, r2, r6
  30:	00001620 	andeq	r1, r0, r0, lsr #12
  34:	039c0100 	orrseq	r0, ip, #0, 2
  38:	0000010f 	andeq	r0, r0, pc, lsl #2
  3c:	890f5d01 	stmdbhi	pc, {r0, r8, sl, fp, ip, lr}	; <UNPREDICTABLE>
  40:	ac000000 	stcge	0, cr0, [r0], {-0}
  44:	84200001 	strthi	r0, [r0], #-1
  48:	01000000 	mrseq	r0, (UNDEF: 0)
  4c:	0000899c 	muleq	r0, ip, r9
  50:	656b0400 	strbvs	r0, [fp, #-1024]!	; 0xfffffc00
  54:	5e010079 	mcrpl	0, 0, r0, cr1, cr9, {3}
  58:	00009010 	andeq	r9, r0, r0, lsl r0
  5c:	5c910200 	lfmpl	f0, 4, [r1], {0}
  60:	6c6f6304 	stclvs	3, cr6, [pc], #-16	; 58 <startup-0x1fffffa8>
  64:	10620100 	rsbne	r0, r2, r0, lsl #2
  68:	00000089 	andeq	r0, r0, r9, lsl #1
  6c:	056e9102 	strbeq	r9, [lr, #-258]!	; 0xfffffefe
  70:	200001c6 	andcs	r0, r0, r6, asr #3
  74:	00000056 	andeq	r0, r0, r6, asr r0
  78:	776f7204 	strbvc	r7, [pc, -r4, lsl #4]!
  7c:	15630100 	strbne	r0, [r3, #-256]!	; 0xffffff00
  80:	00000089 	andeq	r0, r0, r9, lsl #1
  84:	006f9102 	rsbeq	r9, pc, r2, lsl #2
  88:	08010600 	stmdaeq	r1, {r9, sl}
  8c:	000000f9 	strdeq	r0, [r0], -r9
  90:	00008907 	andeq	r8, r0, r7, lsl #18
  94:	0000a600 	andeq	sl, r0, r0, lsl #12
  98:	00a60800 	adceq	r0, r6, r0, lsl #16
  9c:	08030000 	stmdaeq	r3, {}	; <UNPREDICTABLE>
  a0:	000000a6 	andeq	r0, r0, r6, lsr #1
  a4:	04060003 	streq	r0, [r6], #-3
  a8:	00007c07 	andeq	r7, r0, r7, lsl #24
  ac:	01fb0900 	mvnseq	r0, r0, lsl #18
  b0:	51010000 	mrspl	r0, (UNDEF: 1)
  b4:	00016406 	andeq	r6, r1, r6, lsl #8
  b8:	00004820 	andeq	r4, r0, r0, lsr #16
  bc:	e09c0100 	adds	r0, ip, r0, lsl #2
  c0:	0a000000 	beq	c8 <startup-0x1fffff38>
  c4:	51010063 	tstpl	r1, r3, rrx
  c8:	0000891d 	andeq	r8, r0, sp, lsl r9
  cc:	5f910200 	svcpl	0x00910200
  d0:	0001140b 	andeq	r1, r1, fp, lsl #8
  d4:	07550100 	ldrbeq	r0, [r5, -r0, lsl #2]
  d8:	000000e0 	andeq	r0, r0, r0, ror #1
  dc:	00609102 	rsbeq	r9, r0, r2, lsl #2
  e0:	0000f007 	andeq	pc, r0, r7
  e4:	0000f000 	andeq	pc, r0, r0
  e8:	00a60800 	adceq	r0, r6, r0, lsl #16
  ec:	000f0000 	andeq	r0, pc, r0
  f0:	02080106 	andeq	r0, r8, #-2147483647	; 0x80000001
  f4:	0c000001 	stceq	0, cr0, [r0], {1}
  f8:	0000013b 	andeq	r0, r0, fp, lsr r1
  fc:	21054401 	tstcs	r5, r1, lsl #8
 100:	10000001 	andne	r0, r0, r1
 104:	54200001 	strtpl	r0, [r0], #-1
 108:	01000000 	mrseq	r0, (UNDEF: 0)
 10c:	0001219c 	muleq	r1, ip, r1
 110:	02030b00 	andeq	r0, r3, #0, 22
 114:	48010000 	stmdami	r1, {}	; <UNPREDICTABLE>
 118:	00008910 	andeq	r8, r0, r0, lsl r9
 11c:	77910200 	ldrvc	r0, [r1, r0, lsl #4]
 120:	05040d00 	streq	r0, [r4, #-3328]	; 0xfffff300
 124:	00746e69 	rsbseq	r6, r4, r9, ror #28
 128:	00014609 	andeq	r4, r1, r9, lsl #12
 12c:	06390100 	ldrteq	r0, [r9], -r0, lsl #2
 130:	200000ae 	andcs	r0, r0, lr, lsr #1
 134:	00000062 	andeq	r0, r0, r2, rrx
 138:	014e9c01 	cmpeq	lr, r1, lsl #24
 13c:	720a0000 	andvc	r0, sl, #0
 140:	0100776f 	tsteq	r0, pc, ror #14
 144:	00a62139 	adceq	r2, r6, r9, lsr r1
 148:	91020000 	mrsls	r0, (UNDEF: 2)
 14c:	f0020074 			; <UNDEFINED> instruction: 0xf0020074
 150:	01000000 	mrseq	r0, (UNDEF: 0)
 154:	009c062e 	addseq	r0, ip, lr, lsr #12
 158:	00122000 	andseq	r2, r2, r0
 15c:	9c010000 	stcls	0, cr0, [r1], {-0}
 160:	00016b0e 	andeq	r6, r1, lr, lsl #22
 164:	06290100 	strteq	r0, [r9], -r0, lsl #2
 168:	20000070 	andcs	r0, r0, r0, ror r0
 16c:	0000002c 	andeq	r0, r0, ip, lsr #32
 170:	530e9c01 	movwpl	r9, #60417	; 0xec01
 174:	01000001 	tsteq	r0, r1
 178:	0010061e 	andseq	r0, r0, lr, lsl r6
 17c:	00602000 	rsbeq	r2, r0, r0
 180:	9c010000 	stcls	0, cr0, [r1], {-0}
 184:	0001070e 	andeq	r0, r1, lr, lsl #14
 188:	06140100 	ldreq	r0, [r4], -r0, lsl #2
 18c:	20000000 	andcs	r0, r0, r0
 190:	0000000c 	andeq	r0, r0, ip
 194:	Address 0x00000194 is out of bounds.


Disassembly of section .debug_abbrev:

00000000 <.debug_abbrev>:
   0:	25011101 	strcs	r1, [r1, #-257]	; 0xfffffeff
   4:	030b130e 	movweq	r1, #45838	; 0xb30e
   8:	550e1b0e 	strpl	r1, [lr, #-2830]	; 0xfffff4f2
   c:	10011117 	andne	r1, r1, r7, lsl r1
  10:	02000017 	andeq	r0, r0, #23
  14:	193f002e 	ldmdbne	pc!, {r1, r2, r3, r5}	; <UNPREDICTABLE>
  18:	0b3a0e03 	bleq	e8382c <startup-0x1f17c7d4>
  1c:	0b390b3b 	bleq	e42d10 <startup-0x1f1bd2f0>
  20:	01111927 	tsteq	r1, r7, lsr #18
  24:	18400612 	stmdane	r0, {r1, r4, r9, sl}^
  28:	00194296 	mulseq	r9, r6, r2
  2c:	012e0300 			; <UNDEFINED> instruction: 0x012e0300
  30:	0e03193f 			; <UNDEFINED> instruction: 0x0e03193f
  34:	0b3b0b3a 	bleq	ec2d24 <startup-0x1f13d2dc>
  38:	19270b39 	stmdbne	r7!, {r0, r3, r4, r5, r8, r9, fp}
  3c:	01111349 	tsteq	r1, r9, asr #6
  40:	18400612 	stmdane	r0, {r1, r4, r9, sl}^
  44:	01194296 			; <UNDEFINED> instruction: 0x01194296
  48:	04000013 	streq	r0, [r0], #-19	; 0xffffffed
  4c:	08030034 	stmdaeq	r3, {r2, r4, r5}
  50:	0b3b0b3a 	bleq	ec2d40 <startup-0x1f13d2c0>
  54:	13490b39 	movtne	r0, #39737	; 0x9b39
  58:	00001802 	andeq	r1, r0, r2, lsl #16
  5c:	11010b05 	tstne	r1, r5, lsl #22
  60:	00061201 	andeq	r1, r6, r1, lsl #4
  64:	00240600 	eoreq	r0, r4, r0, lsl #12
  68:	0b3e0b0b 	bleq	f82c9c <startup-0x1f07d364>
  6c:	00000e03 	andeq	r0, r0, r3, lsl #28
  70:	49010107 	stmdbmi	r1, {r0, r1, r2, r8}
  74:	00130113 	andseq	r0, r3, r3, lsl r1
  78:	00210800 	eoreq	r0, r1, r0, lsl #16
  7c:	0b2f1349 	bleq	bc4da8 <startup-0x1f43b258>
  80:	2e090000 	cdpcs	0, 0, cr0, cr9, cr0, {0}
  84:	03193f01 	tsteq	r9, #1, 30
  88:	3b0b3a0e 	blcc	2ce8c8 <startup-0x1fd31738>
  8c:	270b390b 	strcs	r3, [fp, -fp, lsl #18]
  90:	12011119 	andne	r1, r1, #1073741830	; 0x40000006
  94:	97184006 	ldrls	r4, [r8, -r6]
  98:	13011942 	movwne	r1, #6466	; 0x1942
  9c:	050a0000 	streq	r0, [sl, #-0]
  a0:	3a080300 	bcc	200ca8 <startup-0x1fdff358>
  a4:	390b3b0b 	stmdbcc	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
  a8:	0213490b 	andseq	r4, r3, #180224	; 0x2c000
  ac:	0b000018 	bleq	114 <startup-0x1ffffeec>
  b0:	0e030034 	mcreq	0, 0, r0, cr3, cr4, {1}
  b4:	0b3b0b3a 	bleq	ec2da4 <startup-0x1f13d25c>
  b8:	13490b39 	movtne	r0, #39737	; 0x9b39
  bc:	00001802 	andeq	r1, r0, r2, lsl #16
  c0:	3f012e0c 	svccc	0x00012e0c
  c4:	3a0e0319 	bcc	380d30 <startup-0x1fc7f2d0>
  c8:	390b3b0b 	stmdbcc	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
  cc:	4919270b 	ldmdbmi	r9, {r0, r1, r3, r8, r9, sl, sp}
  d0:	12011113 	andne	r1, r1, #-1073741820	; 0xc0000004
  d4:	97184006 	ldrls	r4, [r8, -r6]
  d8:	13011942 	movwne	r1, #6466	; 0x1942
  dc:	240d0000 	strcs	r0, [sp], #-0
  e0:	3e0b0b00 	vmlacc.f64	d0, d11, d0
  e4:	0008030b 	andeq	r0, r8, fp, lsl #6
  e8:	002e0e00 	eoreq	r0, lr, r0, lsl #28
  ec:	0e03193f 			; <UNDEFINED> instruction: 0x0e03193f
  f0:	0b3b0b3a 	bleq	ec2de0 <startup-0x1f13d220>
  f4:	19270b39 	stmdbne	r7!, {r0, r3, r4, r5, r8, r9, fp}
  f8:	06120111 			; <UNDEFINED> instruction: 0x06120111
  fc:	42971840 	addsmi	r1, r7, #64, 16	; 0x400000
 100:	00000019 	andeq	r0, r0, r9, lsl r0

Disassembly of section .debug_aranges:

00000000 <.debug_aranges>:
   0:	00000024 	andeq	r0, r0, r4, lsr #32
   4:	00000002 	andeq	r0, r0, r2
   8:	00040000 	andeq	r0, r4, r0
   c:	00000000 	andeq	r0, r0, r0
  10:	20000010 	andcs	r0, r0, r0, lsl r0
  14:	00000236 	andeq	r0, r0, r6, lsr r2
  18:	20000000 	andcs	r0, r0, r0
  1c:	0000000c 	andeq	r0, r0, ip
	...

Disassembly of section .debug_ranges:

00000000 <.debug_ranges>:
   0:	20000010 	andcs	r0, r0, r0, lsl r0
   4:	20000246 	andcs	r0, r0, r6, asr #4
   8:	20000000 	andcs	r0, r0, r0
   c:	2000000c 	andcs	r0, r0, ip
	...

Disassembly of section .debug_line:

00000000 <.debug_line>:
   0:	000001b6 			; <UNDEFINED> instruction: 0x000001b6
   4:	00860003 	addeq	r0, r6, r3
   8:	01020000 	mrseq	r0, (UNDEF: 2)
   c:	000d0efb 	strdeq	r0, [sp], -fp
  10:	01010101 	tsteq	r1, r1, lsl #2
  14:	01000000 	mrseq	r0, (UNDEF: 0)
  18:	43010000 	movwmi	r0, #4096	; 0x1000
  1c:	73552f3a 	cmpvc	r5, #58, 30	; 0xe8
  20:	2f737265 	svccs	0x00737265
  24:	666f6c6f 	strbtvs	r6, [pc], -pc, ror #24
  28:	6f442f73 	svcvs	0x00442f73
  2c:	656d7563 	strbvs	r7, [sp, #-1379]!	; 0xfffffa9d
  30:	2f73746e 	svccs	0x0073746e
  34:	5f746967 	svcpl	0x00746967
  38:	6a6f7270 	bvs	1bdca00 <startup-0x1e423600>
  3c:	73746365 	cmnvc	r4, #-1811939327	; 0x94000001
  40:	6863532f 	stmdavs	r3!, {r0, r1, r2, r3, r5, r8, r9, ip, lr}^
  44:	506c6f6f 	rsbpl	r6, ip, pc, ror #30
  48:	656a6f72 	strbvs	r6, [sl, #-3954]!	; 0xfffff08e
  4c:	2f737463 	svccs	0x00737463
  50:	30544144 	subscc	r4, r4, r4, asr #2
  54:	6f2f3731 	svcvs	0x002f3731
  58:	5f666f6c 	svcpl	0x00666f6c
  5c:	746e6f63 	strbtvc	r6, [lr], #-3939	; 0xfffff09d
  60:	2f746e65 	svccs	0x00746e65
  64:	65646f43 	strbvs	r6, [r4, #-3907]!	; 0xfffff0bd
  68:	6574694c 	ldrbvs	r6, [r4, #-2380]!	; 0xfffff6b4
  6c:	726f772f 	rsbvc	r7, pc, #12320768	; 0xbc0000
  70:	6170736b 	cmnvs	r0, fp, ror #6
  74:	6c4f6563 	cfstr64vs	mvdx6, [pc], {99}	; 0x63
  78:	6b2f666f 	blvs	bd9a3c <startup-0x1f4265c4>
  7c:	61707965 	cmnvs	r0, r5, ror #18
  80:	6b000064 	blvs	218 <startup-0x1ffffde8>
  84:	61707965 	cmnvs	r0, r5, ror #18
  88:	00632e64 	rsbeq	r2, r3, r4, ror #28
  8c:	00000001 	andeq	r0, r0, r1
  90:	05000105 	streq	r0, [r0, #-261]	; 0xfffffefb
  94:	00000002 	andeq	r0, r0, r2
  98:	01140320 	tsteq	r4, r0, lsr #6
  9c:	2f212113 	svccs	0x00212113
  a0:	00030221 	andeq	r0, r3, r1, lsr #4
  a4:	25050101 	strcs	r0, [r5, #-257]	; 0xfffffeff
  a8:	10020500 	andne	r0, r2, r0, lsl #10
  ac:	03200000 	nopeq	{0}	; <UNPREDICTABLE>
  b0:	1105011d 	tstne	r5, sp, lsl r1
  b4:	1205672f 	andne	r6, r5, #12320768	; 0xbc0000
  b8:	11057576 	tstne	r5, r6, ror r5
  bc:	0105674c 	tsteq	r5, ip, asr #14
  c0:	922d0575 	eorls	r0, sp, #490733568	; 0x1d400000
  c4:	672f1105 	strvs	r1, [pc, -r5, lsl #2]!
  c8:	05670105 	strbeq	r0, [r7, #-261]!	; 0xfffffefb
  cc:	02058415 	andeq	r8, r5, #352321536	; 0x15000000
  d0:	01052f33 	tsteq	r5, r3, lsr pc
  d4:	4026052f 	eormi	r0, r6, pc, lsr #10
  d8:	054c0205 	strbeq	r0, [ip, #-517]	; 0xfffffdfb
  dc:	052f080b 	streq	r0, [pc, #-2059]!	; fffff8d9 <main+0xdffff6a9>
  e0:	0305201b 	movweq	r2, #20507	; 0x501b
  e4:	210b052e 	tstcs	fp, lr, lsr #10
  e8:	05201b05 	streq	r1, [r0, #-2821]!	; 0xfffff4fb
  ec:	0b052e03 	bleq	14b900 <startup-0x1feb4700>
  f0:	201b0521 	andscs	r0, fp, r1, lsr #10
  f4:	052e0305 	streq	r0, [lr, #-773]!	; 0xfffffcfb
  f8:	1b05210b 	blne	14852c <startup-0x1feb7ad4>
  fc:	2e030520 	cfsh32cs	mvfx0, mvfx3, #16
 100:	05210c05 	streq	r0, [r1, #-3077]!	; 0xfffff3fb
 104:	0105201c 	tsteq	r5, ip, lsl r0
 108:	76170530 			; <UNDEFINED> instruction: 0x76170530
 10c:	05411405 	strbeq	r1, [r1, #-1029]	; 0xfffffbfb
 110:	16052012 			; <UNDEFINED> instruction: 0x16052012
 114:	4a05053d 	bmi	141610 <startup-0x1febe9f0>
 118:	02002205 	andeq	r2, r0, #1342177280	; 0x50000000
 11c:	05200104 	streq	r0, [r0, #-260]!	; 0xfffffefc
 120:	05052f16 	streq	r2, [r5, #-3862]	; 0xfffff0ea
 124:	0022054a 	eoreq	r0, r2, sl, asr #10
 128:	20010402 	andcs	r0, r1, r2, lsl #8
 12c:	052f1605 	streq	r1, [pc, #-1541]!	; fffffb2f <main+0xdffff8ff>
 130:	22054a05 	andcs	r4, r5, #20480	; 0x5000
 134:	01040200 	mrseq	r0, R12_usr
 138:	2f160520 	svccs	0x00160520
 13c:	054a0505 	strbeq	r0, [sl, #-1285]	; 0xfffffafb
 140:	04020022 	streq	r0, [r2], #-34	; 0xffffffde
 144:	09052001 	stmdbeq	r5, {r0, sp}
 148:	2101052f 	tstcs	r1, pc, lsr #10
 14c:	05682005 	strbeq	r2, [r8, #-5]!
 150:	05056a07 	streq	r6, [r5, #-2567]	; 0xfffff5f9
 154:	4b350575 	blmi	d41730 <startup-0x1f2be8d0>
 158:	052e0305 	streq	r0, [lr, #-773]!	; 0xfffffcfb
 15c:	12052035 	andne	r2, r5, #53	; 0x35
 160:	2401052e 	strcs	r0, [r1], #-1326	; 0xfffffad2
 164:	051e0305 	ldreq	r0, [lr, #-773]	; 0xfffffcfb
 168:	01052012 	tsteq	r5, r2, lsl r0
 16c:	921b0530 	andsls	r0, fp, #48, 10	; 0xc000000
 170:	6a3d1005 	bvs	f4418c <startup-0x1f0bbe74>
 174:	054b1505 	strbeq	r1, [fp, #-1285]	; 0xfffffafb
 178:	03054a02 	movweq	r4, #23042	; 0x5a02
 17c:	67090521 	strvs	r0, [r9, -r1, lsr #10]
 180:	053c0705 	ldreq	r0, [ip, #-1797]!	; 0xfffff8fb
 184:	12053d06 	andne	r3, r5, #384	; 0x180
 188:	3c19054b 	cfldr32cc	mvfx0, [r9], {75}	; 0x4b
 18c:	053c1505 	ldreq	r1, [ip, #-1285]!	; 0xfffffafb
 190:	0402002b 	streq	r0, [r2], #-43	; 0xffffffd5
 194:	02055402 	andeq	r5, r5, #33554432	; 0x2000000
 198:	01040200 	mrseq	r0, R12_usr
 19c:	09055f66 	stmdbeq	r5, {r1, r2, r5, r6, r8, r9, sl, fp, ip, lr}
 1a0:	0001053d 	andeq	r0, r1, sp, lsr r5
 1a4:	21010402 	tstcs	r1, r2, lsl #8
 1a8:	05691105 	strbeq	r1, [r9, #-261]!	; 0xfffffefb
 1ac:	03052f02 	movweq	r2, #24322	; 0x5f02
 1b0:	01040200 	mrseq	r0, R12_usr
 1b4:	00070230 	andeq	r0, r7, r0, lsr r2
 1b8:	Address 0x000001b8 is out of bounds.


Disassembly of section .debug_str:

00000000 <.debug_str>:
   0:	20554e47 	subscs	r4, r5, r7, asr #28
   4:	20393943 	eorscs	r3, r9, r3, asr #18
   8:	2e322e39 	mrccs	14, 1, r2, cr2, cr9, {1}
   c:	30322031 	eorscc	r2, r2, r1, lsr r0
  10:	30313931 	eorscc	r3, r1, r1, lsr r9
  14:	28203532 	stmdacs	r0!, {r1, r4, r5, r8, sl, ip, sp}
  18:	656c6572 	strbvs	r6, [ip, #-1394]!	; 0xfffffa8e
  1c:	29657361 	stmdbcs	r5!, {r0, r5, r6, r8, r9, ip, sp, lr}^
  20:	52415b20 	subpl	r5, r1, #32, 22	; 0x8000
  24:	72612f4d 	rsbvc	r2, r1, #308	; 0x134
  28:	2d392d6d 	ldccs	13, cr2, [r9, #-436]!	; 0xfffffe4c
  2c:	6e617262 	cdpvs	2, 6, cr7, cr1, cr2, {3}
  30:	72206863 	eorvc	r6, r0, #6488064	; 0x630000
  34:	73697665 	cmnvc	r9, #105906176	; 0x6500000
  38:	206e6f69 	rsbcs	r6, lr, r9, ror #30
  3c:	35373732 	ldrcc	r3, [r7, #-1842]!	; 0xfffff8ce
  40:	205d3939 	subscs	r3, sp, r9, lsr r9
  44:	68746d2d 	ldmdavs	r4!, {r0, r2, r3, r5, r8, sl, fp, sp, lr}^
  48:	20626d75 	rsbcs	r6, r2, r5, ror sp
  4c:	6c666d2d 	stclvs	13, cr6, [r6], #-180	; 0xffffff4c
  50:	2d74616f 	ldfcse	f6, [r4, #-444]!	; 0xfffffe44
  54:	3d696261 	sfmcc	f6, 2, [r9, #-388]!	; 0xfffffe7c
  58:	74666f73 	strbtvc	r6, [r6], #-3955	; 0xfffff08d
  5c:	616d2d20 	cmnvs	sp, r0, lsr #26
  60:	3d686372 	stclcc	3, cr6, [r8, #-456]!	; 0xfffffe38
  64:	766d7261 	strbtvc	r7, [sp], -r1, ror #4
  68:	206d2d36 	rsbcs	r2, sp, r6, lsr sp
  6c:	2d20672d 	stccs	7, cr6, [r0, #-180]!	; 0xffffff4c
  70:	2d20304f 	stccs	0, cr3, [r0, #-316]!	; 0xfffffec4
  74:	3d647473 	cfstrdcc	mvd7, [r4, #-460]!	; 0xfffffe34
  78:	00393963 	eorseq	r3, r9, r3, ror #18
  7c:	69736e75 	ldmdbvs	r3!, {r0, r2, r4, r5, r6, r9, sl, fp, sp, lr}^
  80:	64656e67 	strbtvs	r6, [r5], #-3687	; 0xfffff199
  84:	746e6920 	strbtvc	r6, [lr], #-2336	; 0xfffff6e0
  88:	5c3a4300 	ldcpl	3, cr4, [sl], #-0
  8c:	72657355 	rsbvc	r7, r5, #1409286145	; 0x54000001
  90:	6c6f5c73 	stclvs	12, cr5, [pc], #-460	; fffffecc <main+0xdffffc9c>
  94:	5c73666f 	ldclpl	6, cr6, [r3], #-444	; 0xfffffe44
  98:	75636f44 	strbvc	r6, [r3, #-3908]!	; 0xfffff0bc
  9c:	746e656d 	strbtvc	r6, [lr], #-1389	; 0xfffffa93
  a0:	69675c73 	stmdbvs	r7!, {r0, r1, r4, r5, r6, sl, fp, ip, lr}^
  a4:	72705f74 	rsbsvc	r5, r0, #116, 30	; 0x1d0
  a8:	63656a6f 	cmnvs	r5, #454656	; 0x6f000
  ac:	535c7374 	cmppl	ip, #116, 6	; 0xd0000001
  b0:	6f6f6863 	svcvs	0x006f6863
  b4:	6f72506c 	svcvs	0x0072506c
  b8:	7463656a 	strbtvc	r6, [r3], #-1386	; 0xfffffa96
  bc:	41445c73 	hvcmi	17859	; 0x45c3
  c0:	37313054 			; <UNDEFINED> instruction: 0x37313054
  c4:	6f6c6f5c 	svcvs	0x006c6f5c
  c8:	6f635f66 	svcvs	0x00635f66
  cc:	6e65746e 	cdpvs	4, 6, cr7, cr5, cr14, {3}
  d0:	6f435c74 	svcvs	0x00435c74
  d4:	694c6564 	stmdbvs	ip, {r2, r5, r6, r8, sl, sp, lr}^
  d8:	775c6574 			; <UNDEFINED> instruction: 0x775c6574
  dc:	736b726f 	cmnvc	fp, #-268435450	; 0xf0000006
  e0:	65636170 	strbvs	r6, [r3, #-368]!	; 0xfffffe90
  e4:	666f6c4f 	strbtvs	r6, [pc], -pc, asr #24
  e8:	79656b5c 	stmdbvc	r5!, {r2, r3, r4, r6, r8, r9, fp, sp, lr}^
  ec:	00646170 	rsbeq	r6, r4, r0, ror r1
  f0:	5f707061 	svcpl	0x00707061
  f4:	74696e69 	strbtvc	r6, [r9], #-3689	; 0xfffff197
  f8:	736e7500 	cmnvc	lr, #0, 10
  fc:	656e6769 	strbvs	r6, [lr, #-1897]!	; 0xfffff897
 100:	68632064 	stmdavs	r3!, {r2, r5, r6, sp}^
 104:	73007261 	movwvc	r7, #609	; 0x261
 108:	74726174 	ldrbtvc	r6, [r2], #-372	; 0xfffffe8c
 10c:	6b007075 	blvs	1c2e8 <startup-0x1ffe3d18>
 110:	00627965 	rsbeq	r7, r2, r5, ror #18
 114:	70736964 	rsbsvc	r6, r3, r4, ror #18
 118:	5f79616c 	svcpl	0x0079616c
 11c:	67657337 			; <UNDEFINED> instruction: 0x67657337
 120:	7865685f 	stmdavc	r5!, {r0, r1, r2, r3, r4, r6, fp, sp, lr}^
 124:	5f6f745f 	svcpl	0x006f745f
 128:	69636564 	stmdbvs	r3!, {r2, r5, r6, r8, sl, sp, lr}^
 12c:	5f6c616d 	svcpl	0x006c616d
 130:	61727261 	cmnvs	r2, r1, ror #4
 134:	616d0079 	smcvs	53257	; 0xd009
 138:	6b006e69 	blvs	1bae4 <startup-0x1ffe451c>
 13c:	47627965 	strbmi	r7, [r2, -r5, ror #18]!
 140:	6f437465 	svcvs	0x00437465
 144:	656b006c 	strbvs	r0, [fp, #-108]!	; 0xffffff94
 148:	63416279 	movtvs	r6, #4729	; 0x1279
 14c:	61766974 	cmnvs	r6, r4, ror r9
 150:	69006574 	stmdbvs	r0, {r2, r4, r5, r6, r8, sl, sp, lr}
 154:	5f74696e 	svcpl	0x0074696e
 158:	4f495047 	svcmi	0x00495047
 15c:	6b5f445f 	blvs	17d12e0 <startup-0x1e82ed20>
 160:	61707965 	cmnvs	r0, r5, ror #18
 164:	49485f64 	stmdbmi	r8, {r2, r5, r6, r8, r9, sl, fp, ip, lr}^
 168:	69004847 	stmdbvs	r0, {r0, r1, r2, r6, fp, lr}
 16c:	5f74696e 	svcpl	0x0074696e
 170:	4f495047 	svcmi	0x00495047
 174:	375f445f 			; <UNDEFINED> instruction: 0x375f445f
 178:	6d676553 	cfstr64vs	mvdx6, [r7, #-332]!	; 0xfffffeb4
 17c:	44746e65 	ldrbtmi	r6, [r4], #-3685	; 0xfffff19b
 180:	6c707369 	ldclvs	3, cr7, [r0], #-420	; 0xfffffe5c
 184:	4c5f7961 	mrrcmi	9, 6, r7, pc, cr1	; <UNPREDICTABLE>
 188:	4300574f 	movwmi	r5, #1871	; 0x74f
 18c:	73552f3a 	cmpvc	r5, #58, 30	; 0xe8
 190:	2f737265 	svccs	0x00737265
 194:	666f6c6f 	strbtvs	r6, [pc], -pc, ror #24
 198:	6f442f73 	svcvs	0x00442f73
 19c:	656d7563 	strbvs	r7, [sp, #-1379]!	; 0xfffffa9d
 1a0:	2f73746e 	svccs	0x0073746e
 1a4:	5f746967 	svcpl	0x00746967
 1a8:	6a6f7270 	bvs	1bdcb70 <startup-0x1e423490>
 1ac:	73746365 	cmnvc	r4, #-1811939327	; 0x94000001
 1b0:	6863532f 	stmdavs	r3!, {r0, r1, r2, r3, r5, r8, r9, ip, lr}^
 1b4:	506c6f6f 	rsbpl	r6, ip, pc, ror #30
 1b8:	656a6f72 	strbvs	r6, [sl, #-3954]!	; 0xfffff08e
 1bc:	2f737463 	svccs	0x00737463
 1c0:	30544144 	subscc	r4, r4, r4, asr #2
 1c4:	6f2f3731 	svcvs	0x002f3731
 1c8:	5f666f6c 	svcpl	0x00666f6c
 1cc:	746e6f63 	strbtvc	r6, [lr], #-3939	; 0xfffff09d
 1d0:	2f746e65 	svccs	0x00746e65
 1d4:	65646f43 	strbvs	r6, [r4, #-3907]!	; 0xfffff0bd
 1d8:	6574694c 	ldrbvs	r6, [r4, #-2380]!	; 0xfffff6b4
 1dc:	726f772f 	rsbvc	r7, pc, #12320768	; 0xbc0000
 1e0:	6170736b 	cmnvs	r0, fp, ror #6
 1e4:	6c4f6563 	cfstr64vs	mvdx6, [pc], {99}	; 0x63
 1e8:	6b2f666f 	blvs	bd9bac <startup-0x1f426454>
 1ec:	61707965 	cmnvs	r0, r5, ror #18
 1f0:	656b2f64 	strbvs	r2, [fp, #-3940]!	; 0xfffff09c
 1f4:	64617079 	strbtvs	r7, [r1], #-121	; 0xffffff87
 1f8:	6f00632e 	svcvs	0x0000632e
 1fc:	73377475 	teqvc	r7, #1962934272	; 0x75000000
 200:	72006765 	andvc	r6, r0, #26476544	; 0x1940000
 204:	7246776f 	subvc	r7, r6, #29097984	; 0x1bc0000
 208:	65526d6f 	ldrbvs	r6, [r2, #-3439]	; 0xfffff291
 20c:	74736967 	ldrbtvc	r6, [r3], #-2407	; 0xfffff699
 210:	Address 0x00000210 is out of bounds.


Disassembly of section .comment:

00000000 <.comment>:
   0:	3a434347 	bcc	10d0d24 <startup-0x1ef2f2dc>
   4:	4e472820 	cdpmi	8, 4, cr2, cr7, cr0, {1}
   8:	6f542055 	svcvs	0x00542055
   c:	20736c6f 	rsbscs	r6, r3, pc, ror #24
  10:	20726f66 	rsbscs	r6, r2, r6, ror #30
  14:	206d7241 	rsbcs	r7, sp, r1, asr #4
  18:	65626d45 	strbvs	r6, [r2, #-3397]!	; 0xfffff2bb
  1c:	64656464 	strbtvs	r6, [r5], #-1124	; 0xfffffb9c
  20:	6f725020 	svcvs	0x00725020
  24:	73736563 	cmnvc	r3, #415236096	; 0x18c00000
  28:	2073726f 	rsbscs	r7, r3, pc, ror #4
  2c:	30322d39 	eorscc	r2, r2, r9, lsr sp
  30:	712d3931 			; <UNDEFINED> instruction: 0x712d3931
  34:	616d2d34 	cmnvs	sp, r4, lsr sp
  38:	29726f6a 	ldmdbcs	r2!, {r1, r3, r5, r6, r8, r9, sl, fp, sp, lr}^
  3c:	322e3920 	eorcc	r3, lr, #32, 18	; 0x80000
  40:	3220312e 	eorcc	r3, r0, #-2147483637	; 0x8000000b
  44:	31393130 	teqcc	r9, r0, lsr r1
  48:	20353230 	eorscs	r3, r5, r0, lsr r2
  4c:	6c657228 	sfmvs	f7, 2, [r5], #-160	; 0xffffff60
  50:	65736165 	ldrbvs	r6, [r3, #-357]!	; 0xfffffe9b
  54:	415b2029 	cmpmi	fp, r9, lsr #32
  58:	612f4d52 			; <UNDEFINED> instruction: 0x612f4d52
  5c:	392d6d72 	pushcc	{r1, r4, r5, r6, r8, sl, fp, sp, lr}
  60:	6172622d 	cmnvs	r2, sp, lsr #4
  64:	2068636e 	rsbcs	r6, r8, lr, ror #6
  68:	69766572 	ldmdbvs	r6!, {r1, r4, r5, r6, r8, sl, sp, lr}^
  6c:	6e6f6973 			; <UNDEFINED> instruction: 0x6e6f6973
  70:	37373220 	ldrcc	r3, [r7, -r0, lsr #4]!
  74:	5d393935 			; <UNDEFINED> instruction: 0x5d393935
	...

Disassembly of section .ARM.attributes:

00000000 <.ARM.attributes>:
   0:	00002a41 	andeq	r2, r0, r1, asr #20
   4:	61656100 	cmnvs	r5, r0, lsl #2
   8:	01006962 	tsteq	r0, r2, ror #18
   c:	00000020 	andeq	r0, r0, r0, lsr #32
  10:	4d2d3605 	stcmi	6, cr3, [sp, #-20]!	; 0xffffffec
  14:	070b0600 	streq	r0, [fp, -r0, lsl #12]
  18:	1201094d 	andne	r0, r1, #1261568	; 0x134000
  1c:	15011404 	strne	r1, [r1, #-1028]	; 0xfffffbfc
  20:	18031701 	stmdane	r3, {r0, r8, r9, sl, ip}
  24:	1a011901 	bne	46430 <startup-0x1ffb9bd0>
  28:	Address 0x00000028 is out of bounds.


Disassembly of section .debug_frame:

00000000 <.debug_frame>:
   0:	0000000c 	andeq	r0, r0, ip
   4:	ffffffff 			; <UNDEFINED> instruction: 0xffffffff
   8:	7c020001 	stcvc	0, cr0, [r2], {1}
   c:	000d0c0e 	andeq	r0, sp, lr, lsl #24
  10:	0000000c 	andeq	r0, r0, ip
  14:	00000000 	andeq	r0, r0, r0
  18:	20000000 	andcs	r0, r0, r0
  1c:	0000000c 	andeq	r0, r0, ip
  20:	00000018 	andeq	r0, r0, r8, lsl r0
  24:	00000000 	andeq	r0, r0, r0
  28:	20000010 	andcs	r0, r0, r0, lsl r0
  2c:	00000060 	andeq	r0, r0, r0, rrx
  30:	87080e41 	strhi	r0, [r8, -r1, asr #28]
  34:	41018e02 	tstmi	r1, r2, lsl #28
  38:	0000070d 	andeq	r0, r0, sp, lsl #14
  3c:	00000018 	andeq	r0, r0, r8, lsl r0
  40:	00000000 	andeq	r0, r0, r0
  44:	20000070 	andcs	r0, r0, r0, ror r0
  48:	0000002c 	andeq	r0, r0, ip, lsr #32
  4c:	87080e41 	strhi	r0, [r8, -r1, asr #28]
  50:	41018e02 	tstmi	r1, r2, lsl #28
  54:	0000070d 	andeq	r0, r0, sp, lsl #14
  58:	00000018 	andeq	r0, r0, r8, lsl r0
  5c:	00000000 	andeq	r0, r0, r0
  60:	2000009c 	mulcs	r0, ip, r0
  64:	00000012 	andeq	r0, r0, r2, lsl r0
  68:	87080e41 	strhi	r0, [r8, -r1, asr #28]
  6c:	41018e02 	tstmi	r1, r2, lsl #28
  70:	0000070d 	andeq	r0, r0, sp, lsl #14
  74:	0000001c 	andeq	r0, r0, ip, lsl r0
  78:	00000000 	andeq	r0, r0, r0
  7c:	200000ae 	andcs	r0, r0, lr, lsr #1
  80:	00000062 	andeq	r0, r0, r2, rrx
  84:	87080e41 	strhi	r0, [r8, -r1, asr #28]
  88:	41018e02 	tstmi	r1, r2, lsl #28
  8c:	0d41100e 	stcleq	0, cr1, [r1, #-56]	; 0xffffffc8
  90:	00000007 	andeq	r0, r0, r7
  94:	0000001c 	andeq	r0, r0, ip, lsl r0
  98:	00000000 	andeq	r0, r0, r0
  9c:	20000110 	andcs	r0, r0, r0, lsl r1
  a0:	00000054 	andeq	r0, r0, r4, asr r0
  a4:	87080e41 	strhi	r0, [r8, -r1, asr #28]
  a8:	41018e02 	tstmi	r1, r2, lsl #28
  ac:	0d41100e 	stcleq	0, cr1, [r1, #-56]	; 0xffffffc8
  b0:	00000007 	andeq	r0, r0, r7
  b4:	00000020 	andeq	r0, r0, r0, lsr #32
  b8:	00000000 	andeq	r0, r0, r0
  bc:	20000164 	andcs	r0, r0, r4, ror #2
  c0:	00000048 	andeq	r0, r0, r8, asr #32
  c4:	84100e41 	ldrhi	r0, [r0], #-3649	; 0xfffff1bf
  c8:	87038504 	strhi	r8, [r3, -r4, lsl #10]
  cc:	41018e02 	tstmi	r1, r2, lsl #28
  d0:	0d41280e 	stcleq	8, cr2, [r1, #-56]	; 0xffffffc8
  d4:	00000007 	andeq	r0, r0, r7
  d8:	0000001c 	andeq	r0, r0, ip, lsl r0
  dc:	00000000 	andeq	r0, r0, r0
  e0:	200001ac 	andcs	r0, r0, ip, lsr #3
  e4:	00000084 	andeq	r0, r0, r4, lsl #1
  e8:	840c0e41 	strhi	r0, [ip], #-3649	; 0xfffff1bf
  ec:	8e028703 	cdphi	7, 0, cr8, cr2, cr3, {0}
  f0:	280e4101 	stmdacs	lr, {r0, r8, lr}
  f4:	00070d41 	andeq	r0, r7, r1, asr #26
  f8:	00000018 	andeq	r0, r0, r8, lsl r0
  fc:	00000000 	andeq	r0, r0, r0
 100:	20000230 	andcs	r0, r0, r0, lsr r2
 104:	00000016 	andeq	r0, r0, r6, lsl r0
 108:	87080e41 	strhi	r0, [r8, -r1, asr #28]
 10c:	41018e02 	tstmi	r1, r2, lsl #28
 110:	0000070d 	andeq	r0, r0, sp, lsl #14
